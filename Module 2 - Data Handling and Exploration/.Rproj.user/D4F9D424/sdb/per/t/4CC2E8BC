{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Subsetting and Aggregation\"\nauthor: \"Irfan Kanat\"\ndate: \"July 3, 2017\"\noutput:\n  pdf_document: default\n  html_document: default\ngeometry: margin=1in\nurlcolor: blue\n---\n\n\n\nFollowing the first two learning activities of this module, we now know quite a bit about figuring out the characteristics of our datasets. In this learning activity we will learn about pre-processing data to obtain useful subsets and aggregations of data.\n\n## Introducing Data\n\nYou may remember the **ZRI Summary: Multifamily, SFR, Condo/Co-op (Current Month)** dataset from Assignment 1. I will use the same dataset for demonstration purposes.\n\n```{r}\nzillow <- read.csv(\"data/zillow.csv\")\nView(zillow)\n```\n\n## Subsetting with Indexes\n\nSubsetting is selecting a smaller sample from available data, be it observations (rows) or variables (columns).\n\n### Variables\n\nWe have covered filtering the data in two separate learning activities thus far. Same principles can be used to extract a subset.\n\nWe know by now various ways to extract specific columns. Here are some new twists.\n\n**Dropping a Column**\n\nLet us say I want to drop a single column (MoM).\n\n```{r}\ncolnames(zillow) # names of columns\n# MoM is the 9th column\nzillowSS0 <- zillow[, -9] # A negative indice will exclude that column\ncolnames(zillowSS0)\n```\n\nYou can also drop multiple columns by combining negative indices.\n\n```{r}\nzillowSS1 <- zillow[, c(-9, -10)]\ncolnames(zillowSS1)\n```\n\nI will now remove these subset datasets as they are cluttering the working environment (and to demonstrate rm() function).\n\n```{r}\nrm(zillowSS0, zillowSS1)\n```\n\n***This is a bit harder to follow but I am including it here for sake reminding you about logical operators and how they work in indexes.*** \n\nA way to do the same with column name.\n\n```{r}\n# This is harder to follow, but achieves the same thing\nzillowSS0 <- zillow[, !(colnames(zillow) %in% \"MoM\")]\ncolnames(zillowSS0)\n```\n\nLet us break it down.\n\nYou know what zillow[,] does, it allows us to use indexes to call various rows and columns.\n\nLet us look at what the other parts do.\n\n```{r}\n# This shows you if the column name matches MoM\ncolnames(zillow) %in% \"MoM\"\n# If you use it to index zillow you will only get MoM\n# The exclamation mark reverts it, Trues become False and Falses become True\n!(colnames(zillow) %in% \"MoM\")\n# When we feed this to the index, we get all columns except \"MoM\"\n```\n\nYou learned about two new operators %in% (matching) and ! (inverse). \n\n### Observations\n\nYou may be interested in only certain rows in a dataset. \n\nLet us say we want to focus on rent in Ohio counties only. You remember logic operators from earlier learning activities. \n\n```{r}\nzillowOH <- zillow[zillow$State == \"OH\", ]\n```\n\nzillow$State == \"OH\" will return an array of True/False results. It will be true where State is Ohio, and false otherwise. When we feed this logical operation into the row index, and R will only return observations where evaluation resulted in True.\n\nWe can also combine multiple criteria in our filtering. Let us say we are interested in rent in Ohio counties but only for areas where Zri is lower than $1000.\n\n```{r}\nzillowOHCheap <- zillow[zillow$State == \"OH\" & zillow$Zri < 1000, ]\n```\n\nWe used an & (and operator) to combine two logical operations, R only returns results where both conditions evaluate True. \n\nLet us say you have some flexibility, you are looking for a rental in Ohio ***or*** West Virginia.\n\n```{r}\nzillowOHWV <- zillow[zillow$State == \"OH\" | zillow$State == \"WV\", ]\n```\n\nHere we used a | (or operator) to combine two logical operations, R only returns results where at least one condition is True.\n\nLet us clean the workspace by removing some datasets.\n\n```{r}\n# Yeah, this may be a bit obscure at the moment. Try to figure it out, its good exercise.\nrm(list = ls(pattern = \"zillowOH*\"))\n```\n\nHere is a little exercise for you. Considering there are `r nrow(zillow)` observations in zillow dataset, can you make R randomly select 50 numbers between 1 and `r nrow(zillow)` and create a random subset? Hint: read about sample function.\n\n## Subset Function\n\nSubset function can do both variable and column subsetting at the same time and it has a more intuitive interface than indexing.\n\nCheck the manual pages. \n\n```{r}\n?subset\n```\n\nThe subset syntax is as follows:\n\n    subset(x, subset, select, drop)\n    \n  + x is the data to be subsetted.\n  + subset is the criteria for rows.\n  + select is the list of columns to keep\n  \nonly x is mandatory.\n\n### Selecting Variables\n\nLet us just select State, County, and Zri from zillow dataset.\n\n```{r}\n# Note the lack of quotation marks\nzillowSS0 <- subset(zillow, select = c(State, County, Zri))\ncolnames(zillowSS0) # names of columns\nhead(zillowSS0) # A sampling of data\n```\n\nHere I called subset with two parameters.\n1. zillow: I specified which data is to be subsetted.\n2. select=c(State, County, Zri): I specified which columns I wanted to keep.\n\nOne nice thing about subset is that you can use ranges of columns with names just like with ranges of numbers. Let us say we want all variables between date and zri.\n\n```{r}\n# Note the lack of quotation marks\nzillowSS1 <- subset(zillow, select = Date:Zri)\ncolnames(zillowSS1) # names of columns\nhead(zillowSS1) # A sampling of data\n```\n\nHere I called subset with two parameters again.\n1. zillow: the dataset\n2. select=Date:Zri: I specified a range of columns from Date to Zri.\n\n```{r}\nrm(list = ls(pattern = \"zillowSS*\"))\n```\n\n### Selecting Observations\n\nJust as in the indexing, we can use logical operators to extract specific rows.\n\nLet us carry out that example of Ohio or West Virginia.\n\n```{r}\nzillowOHWV <- subset(zillow, State == \"OH\" | State == \"WV\")\nhead(zillowOHWV)\n```\n\nHere I called subset with two parameters\n1. zillow: the dataset\n2. State == \"OH\" | State == \"WV\": State is OH or WV \n\nPlain language translation of this command is: \"get me the rows from zillow dataset where the state is either Ohio or West Virginia.\"\n\n```{r}\nrm(zillowOHWV)\n```\n\n### Selecting Both\n\nWe can subset both variables and observations at the same time.\n\n```{r}\nzillowOW <- subset(zillow, \n                   (State == \"OH\" | State == \"WV\") & Zri < 1000,\n                   select = Date:Zri)\n```\n\nSame idea, only made more complicated by including both row and column subsetting. Parameters:\n1. zillow: dataset\n2. (State==\"OH\" | State==\"WV\") & Zri<1000: State is Ohio or West Virginia, and Zri is less than 1000\n3. select=Date:Zri: columns between Date and Zri\n\nPlain language translation of this command is: \"Get me columns from Date to Zri of the zillow dataset, where the state is either Ohio or West Virginia, and the Zri is less than 1000.\"\n\n```{r}\nrm(zillowOW)\n```\n\n## Aggregating\n\nZillow Data is at zip code level. Let us say we are interested in State level data. We do not care about specific zip codes. Should we look for state level data elsewhere or is there a way to convert the zip code level data to state level.\n\nWhat we can do is to aggregate the zip code level data to obtain a State level dataset.\n\nAggregating allows you to come up with combined measures for broad categories from lower level observations. You can aggregate individual student scores to obtain a school level score, or company level profitability data to obtain industry level profitability measures.\n\nWhen you are aggregating data you need to make certain decisions about variables. Certain variables are more meaningful as averages (average rent in OH), other variables are more meaningful as sums (population), and yet others as maximums (Dates). Some variables will need to be abandoned all together (zip codes). The correct function to use will depend on the analysis you want to do. It is a judgment call, and it is hard to teach. Just use your intuition and try to learn from your mistakes as you go.\n\nThe simplest way to aggregate data that is available in R Base is the aggregate() function. Let us inspect manual pages for aggregate().\n\n```{r}\n?aggregate\n```\n\naggregate() can work either with a formula or with a by parameter.\n\n### Aggregate By\n\nWe can specify the columns to aggregate by and aggregate will process all numeric columns (unless otherwise indicated).\n\nLet us drop all non-numeric columns, you will note this is mostly lower level data such as city names that will need to be dropped anyway:\n\n```{r}\n# Let us drop non-numeric columns\nzillowSS0 <- subset(zillow, select = c(State, SizeRank:ZriRecordCnt))\n```\n\nLet us calculate average values for all other variables and save it into a new dataset.\n\n```{r}\n# Aggregate\nzillowState <- aggregate(x = zillowSS0[, -1], by = list(zillowSS0$State),\n                         FUN = mean, na.rm = T)\n```\n\nLet us break the command down:\n\n    zillowState <- aggregate(x = zillowSS0[,-1], by = list(zillowSS0$State), FUN = mean, na.rm = T)\n    \n1. zillowState <- : Here I create a new dataset and assign whatever is on the other side of the assignment operator (<-) to it.\n2. aggregate(): I call aggregate function with 4 parameters.\n  + x = zillowSS0[,-1]: Aggregate everything in zillowSS0 except for State (1^st^ column).\n  + by = list(zillowSS0$State): Use State as the aggregating variable\n  + FUN = mean: use mean function to calcuate average values for States.\n  + na.rm = T: Remove missing observations (more on this later).\n  \nTranslation to plain english would be: \"calculate the averages of everything in zillowSS0[,-1] by State, skip missing observations in calculations.\"\n\nIt has 51 observations, same as the number of states... That is encouraging.\n\nLet us see if we got it right, by calculating the average Zri for Ohio and comparing it to aggregated value of Zri.\n\n```{r}\nmean(zillow[zillow$State == \"OH\", \"Zri\"])\nzillowState[zillowState$Group.1 == \"OH\", ]\n```\n\nSeems like we got it right!\n\nYou can change the type of calculation done on a variable by specifying a different function in FUN parameter. You can even use your own functions.\n\n### Aggregate with Formula\n\nR uses formula interface in models, aggregate allows you to use a similar interface to aggregate data.\n\nFormula can be thought of an equation, on the left hand side you have dependent variables and on the right, you have independent variables.\n\n    Zri ~ State\n\nwould mean estimate Zri by State.\n\nTo calculate average Zri by state, we can simply type.\n\n```{r}\naggregate(Zri ~ State, data = zillowSS0, FUN = mean, na.rm = T)\n```\n\nTo obtain the same result as the example in Aggregate By section we can use a . (dot) notation. Rather than giving a list of variables we can place a . to signify all variables in data.\n\n```{r}\naggregate(.~State, data = zillowSS0, FUN = mean, na.rm = T)\n```\n\nLet us go over the function call:\n\n    aggregate(.~State, data=zillowSS0, FUN= mean, na.rm=T)\n    \n1. aggregate(): I call the aggregate function with 4 parameters.\n  + .~State: \n    * . : means all variables\n    * ~ : is like an equals sign in a formula, it translates to estimate whats to my left by whats to my right\n    * State : What will be used to group by, you can add more variables with a + sign.\n  + data = zillowSS0: use zillowSS0 dataset to find variables\n  + FUN = mean: use mean function to aggregate, alternatives can be any function such as sum, max, min...\n  + na.rm = TRUE: Skip missing observations.\n  \nPersonally, I find the formula interface to be cleaner.\n\n## Further Reading\n\nIf you want to see more examples, refer to [Data Manipulation (terrible name choice) section](https://github.com/iekanat/rworkshop/blob/master/4_DataManipulation.Rmd) of my R Workshop. The material was aimed at a more advanced audience, but with the foundations laid in this section you can follow along with it.\n\n## Solutions to Exercises\n\n1-Can you make R randomly select 50 numbers between 1 and `r nrow(zillow)` and create a random subset? \n\n```{r}\n# Setting seed for random number generator to ensure reproducability\nset.seed(2017)\nzillowRandom <- zillow[sample(1:nrow(zillow), 50), ]\n```",
    "created" : 1503090546790.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1559823172",
    "id" : "4CC2E8BC",
    "lastKnownWriteTime" : 1503091430,
    "last_content_update" : 1503091430147,
    "path" : "~/Dropbox/QBAXXXX/R Content/Module 2 - Data Handling and Exploration/3_Subsetting.Rmd",
    "project_path" : "3_Subsetting.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}