{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Data Manipulation\"\nauthor: \"Irfan Kanat\"\ndate: \"11/09/2015\"\noutput: pdf_document\n---\n\nIn this document, I will try to walk you through some simple data manipulatione examples. As one might guess, data manipulation is sometimes more of an art, than science. Thus, what I can effectively teach you will be limited. We will learn some basic manipulations with dplyr package and vanilla R. dplyr provides a set of sensible functions to throw data around.\n\n```{r, message=FALSE}\nlibrary(dplyr)\n```\n\nWe will conduct our exercise on Worldbank GDP figures and continent information.\n\nThe GDP figures data is in GDP.csv. Let us read in the file.\n\n```{r}\nGDP<-read.csv(\"GDP.csv\")\nhead(GDP)\n```\n\nAs you can see, the data is in what we call the wide format. Each row is a country and observations over time are in columns.\n\nLet us also get the second data set: Continents and country codes.\n\n```{r}\nContinents<-read.csv(\"continent.csv\")\nhead(Continents)\n```\n\n## Combine Two Datasets\n\nThe most basic operation you can do with two datasets is to combine them. If you want to append new observations to an existing dataset, use rbind. If you want to append new variables to an existing dataset, use cbind. Note that the columns/rows need to be compatible in such combinations.\n\n```{r}\n# Append one dataset to another\n# Append rows\nrbind(Continents[1:3,] ,Continents[231:233,])\n# Append columns\ncbind(Continents[1:3,] ,Continents[231:233,])\n```\n\n\nIf you want to combine two datasets based on the values of a common column however, you will need to do a merge. Merging is similar to a join operation in SQL if you are familiar with it. \n\nBelow is the syntax for merge()\n\n```{r, eval=F}\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"))\n```\n\nAs you can see, a lot of the parameters are optional (have default values). Let us use merge to join Continents dataset to GDP dataset.\n\n```{r}\ncData <- merge(Continents, GDP)\nhead(cData)\n```\n\nI did not need to specify which column to merge on as by has a default value of intersect(names(x), names(y)). This means, if there are common column names between two datasets the two will be merged on common column names.\n\nLet us go over some of the more commonly used parameters.\n\nby, by.x, by.y: column name to merge on between quotation marks. If the two datasets have different names, use by.x and by.y to separately specify the column names.\n\n```{r, eval=FALSE}\nmerge(Continents, GDP, by = \"ISO2\")\n```\n\nall, all.x, all.y: It determines what to do with rows that can not be matched in both datasets. From an SQL perspective, the all parameters specify the type of join operation. all.x = TRUE left join (keep rows from left table even if not matched), all.y = TRUE left join, and all = TRUE for an outer join. \n\n## Subset Rows Based on Column Values\n\nIf you want to select certain rows of output based on a column, this is what you do. When we wanted to filter certain observations in the first session we used indexing with logical operations before. \n\nLet us select observations in Oceania first.\n\nFirst let us see how this is done in R:\n\n```{r}\n# displaying the first 6 columns to conserve space\n# !is.na bit is required due to how R matches the == with NA's\ncData[cData$Continent == \"OC\" & !is.na(cData$Continent),1:6] \n```\n\nA better way is to subset the data (subset is part of the base package):\n\n```{r}\nsubset(cData[,1:6], Continent == \"OC\")\n```\n\nWith dplyr:\n\n```{r}\nfilter(cData[,1:6], Continent == \"OC\")\n```\n\nYou can also filter based on multiple columns. Let us say we are interested in countries in Oceania that are rich (GDP greater than 3rd quartile).\n\n```{r}\ncData[cData$Continent == \"OC\" & !is.na(cData$Continent) & cData$X2011 > 23000 & !is.na(cData$X2011),]\n```\n\nI believe you would agree that, it is not very convenient. Filter to the rescue.\n\n```{r}\nfilter(cData, Continent == \"OC\" & X2011 > 23000)\n```\n\n\n\n## Selecting Certain Columns\n\nLet us say we are interested only in the GDP figures and not in any of the country identifiers. We would want to select only certain columns.\n\nTraditional R ways:\n\n```{r}\n# Limiting number of rows to 3 to conserve space\ncData[1:3,4:13] # Indexing by column numbers\ncData[1:3,-(1:3)] # Negative indexing\ncData[1:3,grep(\"X\", colnames(cData))] # Another way based on partial matching column name\n```\n\nsubset can also handle this:\n\n```{r}\nsubset(cData[1:3,], select = -c(ISO2, Continent, Country)) # Drop these columns\n```\n\ndplyr way:\n\n```{r}\nselect(cData[1:3,], X2003:X2012) # All columns between X2003 and X2012\nselect(cData[1:3,], -(ISO2:Country))\n```\n\n## Aggregating based on Groups\n\nLet us say we want to calculate the average GDP per continent in 2011 and the number of countries in each continent. \n\nR way:\n\n```{r}\nCont1 <- aggregate(cData$X2011 ~ cData$Continent, FUN=function(x)mean(x, na.rm=T))\nCont1\nCont2 <- aggregate(cData$X2011 ~ cData$Continent, FUN=function(x) length(x))\nCont2\nCont <- merge(Cont1, Cont2, by='cData$Continent')\nCont\nrm(Cont1, Cont2)\n```\n\ndplyr way:\n\n```{r}\n# Create grouped data\ncontiData <- group_by(cData, Continent)\ncontiData\n# Create variables on the fly\nsummarise(contiData, count=n(), GDP2012 = mean(X2012, na.rm = T))\n```\n\n## Converting Data to Long Format\n\nSo far our data had remained in wide format, yet for most statistical analysis it is more convenient to have it in long format.\n\nLet us learn the use of reshape function. Below is the syntax.\n\n```{r, eval = F}\nreshape(data, varying = NULL, v.names = NULL, timevar = \"time\",\n        idvar = \"id\", ids = 1:NROW(data),\n        times = seq_along(varying[[1]]),\n        drop = NULL, direction, new.row.names = NULL,\n        sep = \".\",\n        split = if (sep == \"\") {\n            list(regexp = \"[A-Za-z][0-9]\", include = TRUE)\n        } else {\n            list(regexp = sep, include = FALSE, fixed = TRUE)}\n        )\n```\n\ndata: data.frame to be reshaped.\nvarying: names of variables that refer to single variables in long format.\nidvar: identifier for observations.\n\n```{r}\ncData_Long <- reshape(cData, varying=4:13, direction=\"long\", sep=\"\")\nhead(cData_Long)\n# Drop the unnecessary id column\ncData_Long <- subset(cData_Long, select = -c(id, Country))\n# Drop the missing observations\ncData_Long <- na.exclude(cData_Long)\n# Get rid of empty levels\ncData_Long$ISO2 <- droplevels(cData_Long$ISO2)\n# Rename variable X to GDP\ncolnames(cData_Long)[4] <- \"GDP\"\n# Sort based on ISO2 and Year\ncData_Long<-cData_Long[order(cData_Long$ISO2,cData_Long$ISO2),]\nhead(cData_Long)\n```\n\n## Traditional Transformations\n\nOften times we will find ourselves creating transformed variables. For logs and other linear transformations, our job is easy. We can just use the function name like so:\n\n```{r}\ncData_Long$logGDP<-log(cData_Long$GDP)\nhead(cData_Long)\n```\n\n\nWhat is more intriguing is to create transformations based on a grouping variable such as cumulative sums for each country. There are many ways to do this, here is one that is done with vanilla R:\n\n```{r}\n# ASSUMING YOUR DATA IS SORTED\ncData_Long$cumGDP <- ave(cData_Long$GDP, cData_Long$ISO2, FUN=cumsum)\n```\n\nOr lagged values for each country. \n\n```{r}\n# ASSUMING YOUR DATA IS SORTED\n# Write a function to lag\n# A function, given a vector, shifts every observation by 1 and drops the last one.\nlg <- function(x) c(NA,x[1:(length(x)-1)]) \nlg(1:10) # See how it works\n# Run the function with group averages function\ncData_Long$lagGDP <- ave(cData_Long$GDP, cData_Long$ISO2, FUN=lg)\nhead(cData_Long)\n```\n\nSave dataset for later use.\n\n```{r}\nwrite.csv(cData_Long, file=\"cDataLong.csv\", row.names=F)\n```\n\n\n------\n\n![Creative Commons 4](figures/cc.png) How I Learned to Stop Worrying and Love the R Console by [Irfan E Kanat](http://irfankanat.com) is licensed under a [Creative Commons Attribution 4.0 International License](http://creativecommons.org/licenses/by/4.0/). Based on a work at [http://github.com/iekanat/rworkshop](http://github.com/iekanat/rworkshop).\n",
    "created" : 1499215372303.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2443066341",
    "id" : "434A5136",
    "lastKnownWriteTime" : 1447522596,
    "last_content_update" : 1447522596,
    "path" : "~/Dropbox/R_Workshop/WorkshopR/4_DataManipulation.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}